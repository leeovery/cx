// src/index.ts
import { existsSync as existsSync4, readFileSync as readFileSync3 } from "fs";
import { join as join4, resolve } from "path";

// src/lib/sync.ts
import { existsSync as existsSync3, rmSync as rmSync2 } from "fs";
import { join as join3 } from "path";

// src/lib/manifest.ts
import { existsSync, mkdirSync, readFileSync, writeFileSync, rmSync } from "fs";
import { dirname, join } from "path";
var MANIFEST_FILE = ".plugins-manifest.json";
function getManifestPath(projectRoot) {
  return join(projectRoot, ".claude", MANIFEST_FILE);
}
function readManifest(projectRoot) {
  const manifestPath = getManifestPath(projectRoot);
  if (!existsSync(manifestPath)) {
    return { plugins: {} };
  }
  try {
    const content = readFileSync(manifestPath, "utf-8");
    return JSON.parse(content);
  } catch {
    return { plugins: {} };
  }
}
function writeManifest(projectRoot, manifest) {
  const manifestPath = getManifestPath(projectRoot);
  const claudeDir = dirname(manifestPath);
  if (!existsSync(claudeDir)) {
    mkdirSync(claudeDir, { recursive: true });
  }
  writeFileSync(manifestPath, JSON.stringify(manifest, null, 2) + "\n");
}
function addPlugin(projectRoot, packageName, version, files) {
  const manifest = readManifest(projectRoot);
  manifest.plugins[packageName] = {
    version,
    files
  };
  writeManifest(projectRoot, manifest);
}
function removePlugin(projectRoot, packageName) {
  const manifest = readManifest(projectRoot);
  delete manifest.plugins[packageName];
  if (Object.keys(manifest.plugins).length === 0) {
    const manifestPath = join(projectRoot, ".claude", MANIFEST_FILE);
    if (existsSync(manifestPath)) {
      rmSync(manifestPath);
    }
  } else {
    writeManifest(projectRoot, manifest);
  }
}
function getPlugins(projectRoot) {
  return readManifest(projectRoot).plugins;
}
function cleanupManifestFiles(projectRoot) {
  const manifest = readManifest(projectRoot);
  const claudeDir = join(projectRoot, ".claude");
  const removedFiles = [];
  for (const [packageName, entry] of Object.entries(manifest.plugins)) {
    for (const file of entry.files) {
      const fullPath = join(claudeDir, file);
      if (existsSync(fullPath)) {
        rmSync(fullPath, { recursive: true, force: true });
        removedFiles.push(file);
      }
    }
  }
  return removedFiles;
}

// src/lib/copier.ts
import { existsSync as existsSync2, mkdirSync as mkdirSync2, cpSync, readdirSync, readFileSync as readFileSync2 } from "fs";
import { createRequire } from "module";
import { dirname as dirname2, join as join2, basename } from "path";
var ASSET_DIRS = ["skills", "commands", "agents", "hooks", "scripts"];
function getPackageVersion(packagePath) {
  try {
    const pkgJson = JSON.parse(readFileSync2(join2(packagePath, "package.json"), "utf-8"));
    return pkgJson.version || "0.0.0";
  } catch {
    return "0.0.0";
  }
}
function isValidAsset(itemPath) {
  const name = basename(itemPath);
  return name !== ".gitkeep";
}
function copyPluginAssets(packagePath, projectRoot) {
  const claudeDir = join2(projectRoot, ".claude");
  const copiedFiles = [];
  for (const assetDir of ASSET_DIRS) {
    const sourcePath = join2(packagePath, assetDir);
    if (!existsSync2(sourcePath)) {
      continue;
    }
    const targetDir = join2(claudeDir, assetDir);
    if (!existsSync2(targetDir)) {
      mkdirSync2(targetDir, { recursive: true });
    }
    const items = readdirSync(sourcePath);
    for (const item of items) {
      if (item === ".gitkeep") continue;
      const itemPath = join2(sourcePath, item);
      const targetPath = join2(targetDir, item);
      if (isValidAsset(itemPath)) {
        cpSync(itemPath, targetPath, { recursive: true });
        copiedFiles.push(`${assetDir}/${item}`);
      }
    }
  }
  return {
    files: copiedFiles,
    version: getPackageVersion(packagePath)
  };
}
function findPluginInNodeModules(packageName, projectRoot) {
  const standardPath = join2(projectRoot, "node_modules", packageName);
  if (existsSync2(standardPath)) {
    return standardPath;
  }
  try {
    const require2 = createRequire(join2(projectRoot, "package.json"));
    const resolved = require2.resolve(`${packageName}/package.json`);
    return dirname2(resolved);
  } catch {
    return null;
  }
}
function hasAssets(packagePath) {
  for (const assetDir of ASSET_DIRS) {
    const dirPath = join2(packagePath, assetDir);
    if (existsSync2(dirPath)) {
      const items = readdirSync(dirPath).filter((f) => f !== ".gitkeep");
      if (items.length > 0) {
        return true;
      }
    }
  }
  return false;
}

// src/lib/sync.ts
function syncPlugins(projectRoot, options = {}) {
  const manifest = readManifest(projectRoot);
  const pluginCount = Object.keys(manifest.plugins).length;
  if (pluginCount === 0) {
    return {
      success: true,
      synced: false,
      reason: "No plugins to sync",
      totalFiles: 0,
      pluginCount: 0,
      removedPlugins: [],
      conflicts: [],
      installedPlugins: []
    };
  }
  if (!options.force) {
    let needsSync = false;
    let reason = "";
    for (const [packageName, entry] of Object.entries(manifest.plugins)) {
      const packagePath = findPluginInNodeModules(packageName, projectRoot);
      if (!packagePath) {
        needsSync = true;
        reason = `${packageName} was uninstalled`;
        break;
      }
      const currentVersion = getPackageVersion(packagePath);
      if (currentVersion !== entry.version) {
        needsSync = true;
        reason = `${packageName} changed (${entry.version} \u2192 ${currentVersion})`;
        break;
      }
    }
    if (!needsSync) {
      return {
        success: true,
        synced: false,
        reason: "All plugins up to date",
        totalFiles: 0,
        pluginCount,
        removedPlugins: [],
        conflicts: [],
        installedPlugins: []
      };
    }
  }
  cleanupManifestFiles(projectRoot);
  const newManifest = { plugins: {} };
  const fileOwnership = /* @__PURE__ */ new Map();
  const conflicts = [];
  const removedPlugins = [];
  const installedPlugins = [];
  let totalFiles = 0;
  for (const [packageName] of Object.entries(manifest.plugins)) {
    const packagePath = findPluginInNodeModules(packageName, projectRoot);
    if (!packagePath) {
      removedPlugins.push(packageName);
      continue;
    }
    if (!hasAssets(packagePath)) {
      continue;
    }
    const result = copyPluginAssets(packagePath, projectRoot);
    if (result.files.length > 0) {
      for (const file of result.files) {
        const existingOwner = fileOwnership.get(file);
        if (existingOwner) {
          conflicts.push(`${file} (${existingOwner} vs ${packageName})`);
        }
        fileOwnership.set(file, packageName);
      }
      newManifest.plugins[packageName] = {
        version: result.version,
        files: result.files
      };
      totalFiles += result.files.length;
      installedPlugins.push({
        name: packageName,
        version: result.version,
        fileCount: result.files.length
      });
    }
  }
  writeManifest(projectRoot, newManifest);
  return {
    success: true,
    synced: true,
    totalFiles,
    pluginCount: Object.keys(newManifest.plugins).length,
    removedPlugins,
    conflicts,
    installedPlugins
  };
}
function addPluginToProject(projectRoot, packageName) {
  const packagePath = findPluginInNodeModules(packageName, projectRoot);
  if (!packagePath) {
    return {
      success: false,
      alreadyExists: false,
      packageName,
      files: [],
      error: `Package ${packageName} not found in node_modules`
    };
  }
  if (!hasAssets(packagePath)) {
    return {
      success: true,
      alreadyExists: false,
      packageName,
      files: []
    };
  }
  const manifest = readManifest(projectRoot);
  const existing = manifest.plugins[packageName];
  if (existing) {
    const claudeDir = join3(projectRoot, ".claude");
    for (const file of existing.files) {
      const fullPath = join3(claudeDir, file);
      if (existsSync3(fullPath)) {
        rmSync2(fullPath, { recursive: true, force: true });
      }
    }
  }
  const result = copyPluginAssets(packagePath, projectRoot);
  if (result.files.length > 0) {
    addPlugin(projectRoot, packageName, result.version, result.files);
  }
  return {
    success: true,
    alreadyExists: !!existing,
    packageName,
    version: result.version,
    files: result.files
  };
}
function listPlugins(projectRoot) {
  const manifest = readManifest(projectRoot);
  return { plugins: manifest.plugins };
}
function removePluginFromProject(projectRoot, packageName) {
  const manifest = readManifest(projectRoot);
  const entry = manifest.plugins[packageName];
  if (!entry) {
    return {
      success: false,
      packageName,
      filesRemoved: [],
      error: `Plugin ${packageName} is not installed`
    };
  }
  const claudeDir = join3(projectRoot, ".claude");
  const filesRemoved = [];
  for (const file of entry.files) {
    const fullPath = join3(claudeDir, file);
    if (existsSync3(fullPath)) {
      rmSync2(fullPath, { recursive: true, force: true });
      filesRemoved.push(file);
    }
  }
  removePlugin(projectRoot, packageName);
  return {
    success: true,
    packageName,
    filesRemoved
  };
}

// src/index.ts
function getPackageName() {
  if (process.env.npm_package_name) {
    return process.env.npm_package_name;
  }
  const pkgPath = join4(process.cwd(), "package.json");
  if (existsSync4(pkgPath)) {
    try {
      const pkg = JSON.parse(readFileSync3(pkgPath, "utf-8"));
      return pkg.name || null;
    } catch {
      return null;
    }
  }
  return null;
}
function findProjectRoot() {
  const initCwd = process.env.INIT_CWD;
  if (initCwd && existsSync4(join4(initCwd, "package.json"))) {
    return initCwd;
  }
  let dir = process.cwd();
  while (dir !== "/") {
    if (!dir.includes("node_modules") && existsSync4(join4(dir, "package.json"))) {
      return dir;
    }
    dir = resolve(dir, "..");
  }
  return process.cwd();
}
function add() {
  const packageName = getPackageName();
  if (!packageName) {
    console.error("[claude-manager] Could not determine package name");
    process.exit(1);
  }
  const projectRoot = findProjectRoot();
  const result = addPluginToProject(projectRoot, packageName);
  if (!result.success) {
    console.error(`[claude-manager] Error: ${result.error}`);
    process.exit(1);
  }
  if (result.files.length === 0) {
    return;
  }
  console.log(`[claude-manager] Installed ${packageName}@${result.version}:`);
  for (const file of result.files) {
    console.log(`  .claude/${file}`);
  }
}
function remove() {
  const packageName = getPackageName();
  if (!packageName) {
    console.error("[claude-manager] Could not determine package name");
    process.exit(1);
  }
  const projectRoot = findProjectRoot();
  const result = removePluginFromProject(projectRoot, packageName);
  if (!result.success) {
    return;
  }
  if (result.filesRemoved.length > 0) {
    console.log(`[claude-manager] Removed ${packageName}:`);
    for (const file of result.filesRemoved) {
      console.log(`  .claude/${file}`);
    }
  }
}
export {
  add,
  addPlugin,
  addPluginToProject,
  cleanupManifestFiles,
  copyPluginAssets,
  findPluginInNodeModules,
  getPackageVersion,
  getPlugins,
  hasAssets,
  listPlugins,
  readManifest,
  remove,
  removePlugin,
  removePluginFromProject,
  syncPlugins,
  writeManifest
};
//# sourceMappingURL=index.js.map