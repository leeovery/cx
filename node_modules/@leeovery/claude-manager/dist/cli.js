#!/usr/bin/env node

// src/cli.ts
import { program } from "commander";
import { existsSync as existsSync4, readFileSync as readFileSync3 } from "fs";
import { dirname as dirname3, join as join4, resolve } from "path";
import { fileURLToPath } from "url";

// src/lib/sync.ts
import { existsSync as existsSync3, rmSync as rmSync2 } from "fs";
import { join as join3 } from "path";

// src/lib/manifest.ts
import { existsSync, mkdirSync, readFileSync, writeFileSync, rmSync } from "fs";
import { dirname, join } from "path";
var MANIFEST_FILE = ".plugins-manifest.json";
function getManifestPath(projectRoot) {
  return join(projectRoot, ".claude", MANIFEST_FILE);
}
function readManifest(projectRoot) {
  const manifestPath = getManifestPath(projectRoot);
  if (!existsSync(manifestPath)) {
    return { plugins: {} };
  }
  try {
    const content = readFileSync(manifestPath, "utf-8");
    return JSON.parse(content);
  } catch {
    return { plugins: {} };
  }
}
function writeManifest(projectRoot, manifest) {
  const manifestPath = getManifestPath(projectRoot);
  const claudeDir = dirname(manifestPath);
  if (!existsSync(claudeDir)) {
    mkdirSync(claudeDir, { recursive: true });
  }
  writeFileSync(manifestPath, JSON.stringify(manifest, null, 2) + "\n");
}
function addPlugin(projectRoot, packageName, version, files) {
  const manifest = readManifest(projectRoot);
  manifest.plugins[packageName] = {
    version,
    files
  };
  writeManifest(projectRoot, manifest);
}
function removePlugin(projectRoot, packageName) {
  const manifest = readManifest(projectRoot);
  delete manifest.plugins[packageName];
  if (Object.keys(manifest.plugins).length === 0) {
    const manifestPath = join(projectRoot, ".claude", MANIFEST_FILE);
    if (existsSync(manifestPath)) {
      rmSync(manifestPath);
    }
  } else {
    writeManifest(projectRoot, manifest);
  }
}
function cleanupManifestFiles(projectRoot) {
  const manifest = readManifest(projectRoot);
  const claudeDir = join(projectRoot, ".claude");
  const removedFiles = [];
  for (const [packageName, entry] of Object.entries(manifest.plugins)) {
    for (const file of entry.files) {
      const fullPath = join(claudeDir, file);
      if (existsSync(fullPath)) {
        rmSync(fullPath, { recursive: true, force: true });
        removedFiles.push(file);
      }
    }
  }
  return removedFiles;
}

// src/lib/copier.ts
import { existsSync as existsSync2, mkdirSync as mkdirSync2, cpSync, readdirSync, readFileSync as readFileSync2 } from "fs";
import { createRequire } from "module";
import { dirname as dirname2, join as join2, basename } from "path";
var ASSET_DIRS = ["skills", "commands", "agents", "hooks", "scripts"];
function getPackageVersion(packagePath) {
  try {
    const pkgJson = JSON.parse(readFileSync2(join2(packagePath, "package.json"), "utf-8"));
    return pkgJson.version || "0.0.0";
  } catch {
    return "0.0.0";
  }
}
function isValidAsset(itemPath) {
  const name = basename(itemPath);
  return name !== ".gitkeep";
}
function copyPluginAssets(packagePath, projectRoot) {
  const claudeDir = join2(projectRoot, ".claude");
  const copiedFiles = [];
  for (const assetDir of ASSET_DIRS) {
    const sourcePath = join2(packagePath, assetDir);
    if (!existsSync2(sourcePath)) {
      continue;
    }
    const targetDir = join2(claudeDir, assetDir);
    if (!existsSync2(targetDir)) {
      mkdirSync2(targetDir, { recursive: true });
    }
    const items = readdirSync(sourcePath);
    for (const item of items) {
      if (item === ".gitkeep") continue;
      const itemPath = join2(sourcePath, item);
      const targetPath = join2(targetDir, item);
      if (isValidAsset(itemPath)) {
        cpSync(itemPath, targetPath, { recursive: true });
        copiedFiles.push(`${assetDir}/${item}`);
      }
    }
  }
  return {
    files: copiedFiles,
    version: getPackageVersion(packagePath)
  };
}
function findPluginInNodeModules(packageName, projectRoot) {
  const standardPath = join2(projectRoot, "node_modules", packageName);
  if (existsSync2(standardPath)) {
    return standardPath;
  }
  try {
    const require2 = createRequire(join2(projectRoot, "package.json"));
    const resolved = require2.resolve(`${packageName}/package.json`);
    return dirname2(resolved);
  } catch {
    return null;
  }
}
function hasAssets(packagePath) {
  for (const assetDir of ASSET_DIRS) {
    const dirPath = join2(packagePath, assetDir);
    if (existsSync2(dirPath)) {
      const items = readdirSync(dirPath).filter((f) => f !== ".gitkeep");
      if (items.length > 0) {
        return true;
      }
    }
  }
  return false;
}

// src/lib/sync.ts
function syncPlugins(projectRoot, options = {}) {
  const manifest = readManifest(projectRoot);
  const pluginCount = Object.keys(manifest.plugins).length;
  if (pluginCount === 0) {
    return {
      success: true,
      synced: false,
      reason: "No plugins to sync",
      totalFiles: 0,
      pluginCount: 0,
      removedPlugins: [],
      conflicts: [],
      installedPlugins: []
    };
  }
  if (!options.force) {
    let needsSync = false;
    let reason = "";
    for (const [packageName, entry] of Object.entries(manifest.plugins)) {
      const packagePath = findPluginInNodeModules(packageName, projectRoot);
      if (!packagePath) {
        needsSync = true;
        reason = `${packageName} was uninstalled`;
        break;
      }
      const currentVersion = getPackageVersion(packagePath);
      if (currentVersion !== entry.version) {
        needsSync = true;
        reason = `${packageName} changed (${entry.version} \u2192 ${currentVersion})`;
        break;
      }
    }
    if (!needsSync) {
      return {
        success: true,
        synced: false,
        reason: "All plugins up to date",
        totalFiles: 0,
        pluginCount,
        removedPlugins: [],
        conflicts: [],
        installedPlugins: []
      };
    }
  }
  cleanupManifestFiles(projectRoot);
  const newManifest = { plugins: {} };
  const fileOwnership = /* @__PURE__ */ new Map();
  const conflicts = [];
  const removedPlugins = [];
  const installedPlugins = [];
  let totalFiles = 0;
  for (const [packageName] of Object.entries(manifest.plugins)) {
    const packagePath = findPluginInNodeModules(packageName, projectRoot);
    if (!packagePath) {
      removedPlugins.push(packageName);
      continue;
    }
    if (!hasAssets(packagePath)) {
      continue;
    }
    const result = copyPluginAssets(packagePath, projectRoot);
    if (result.files.length > 0) {
      for (const file of result.files) {
        const existingOwner = fileOwnership.get(file);
        if (existingOwner) {
          conflicts.push(`${file} (${existingOwner} vs ${packageName})`);
        }
        fileOwnership.set(file, packageName);
      }
      newManifest.plugins[packageName] = {
        version: result.version,
        files: result.files
      };
      totalFiles += result.files.length;
      installedPlugins.push({
        name: packageName,
        version: result.version,
        fileCount: result.files.length
      });
    }
  }
  writeManifest(projectRoot, newManifest);
  return {
    success: true,
    synced: true,
    totalFiles,
    pluginCount: Object.keys(newManifest.plugins).length,
    removedPlugins,
    conflicts,
    installedPlugins
  };
}
function addPluginToProject(projectRoot, packageName) {
  const packagePath = findPluginInNodeModules(packageName, projectRoot);
  if (!packagePath) {
    return {
      success: false,
      alreadyExists: false,
      packageName,
      files: [],
      error: `Package ${packageName} not found in node_modules`
    };
  }
  if (!hasAssets(packagePath)) {
    return {
      success: true,
      alreadyExists: false,
      packageName,
      files: []
    };
  }
  const manifest = readManifest(projectRoot);
  const existing = manifest.plugins[packageName];
  if (existing) {
    const claudeDir = join3(projectRoot, ".claude");
    for (const file of existing.files) {
      const fullPath = join3(claudeDir, file);
      if (existsSync3(fullPath)) {
        rmSync2(fullPath, { recursive: true, force: true });
      }
    }
  }
  const result = copyPluginAssets(packagePath, projectRoot);
  if (result.files.length > 0) {
    addPlugin(projectRoot, packageName, result.version, result.files);
  }
  return {
    success: true,
    alreadyExists: !!existing,
    packageName,
    version: result.version,
    files: result.files
  };
}
function listPlugins(projectRoot) {
  const manifest = readManifest(projectRoot);
  return { plugins: manifest.plugins };
}
function removePluginFromProject(projectRoot, packageName) {
  const manifest = readManifest(projectRoot);
  const entry = manifest.plugins[packageName];
  if (!entry) {
    return {
      success: false,
      packageName,
      filesRemoved: [],
      error: `Plugin ${packageName} is not installed`
    };
  }
  const claudeDir = join3(projectRoot, ".claude");
  const filesRemoved = [];
  for (const file of entry.files) {
    const fullPath = join3(claudeDir, file);
    if (existsSync3(fullPath)) {
      rmSync2(fullPath, { recursive: true, force: true });
      filesRemoved.push(file);
    }
  }
  removePlugin(projectRoot, packageName);
  return {
    success: true,
    packageName,
    filesRemoved
  };
}

// src/cli.ts
var __dirname = dirname3(fileURLToPath(import.meta.url));
function getVersion() {
  try {
    const pkgPath = join4(__dirname, "..", "package.json");
    const pkg = JSON.parse(readFileSync3(pkgPath, "utf-8"));
    return pkg.version || "0.0.0";
  } catch {
    return "0.0.0";
  }
}
function findProjectRoot() {
  const initCwd = process.env.INIT_CWD;
  if (initCwd && existsSync4(join4(initCwd, "package.json"))) {
    return initCwd;
  }
  let dir = process.cwd();
  while (dir !== "/") {
    if (!dir.includes("node_modules") && existsSync4(join4(dir, "package.json"))) {
      return dir;
    }
    dir = resolve(dir, "..");
  }
  return process.cwd();
}
program.name("claude-plugins").description("Plugin manager for Claude Code skills and commands").version(getVersion());
program.command("install").description("Sync all plugins from manifest to .claude directory").option("-f, --force", "Force sync even if versions match").action((options) => {
  const projectRoot = findProjectRoot();
  const result = syncPlugins(projectRoot, options);
  if (!result.synced) {
    console.log(result.reason || "Nothing to sync.");
    return;
  }
  if (options.force) {
    console.log("Syncing Claude plugins (forced)...");
  }
  for (const plugin of result.installedPlugins) {
    console.log(`  Installed ${plugin.name}@${plugin.version} (${plugin.fileCount} files)`);
  }
  if (result.removedPlugins.length > 0) {
    console.log(`
Removed ${result.removedPlugins.length} uninstalled plugin(s) from manifest:`);
    for (const name of result.removedPlugins) {
      console.log(`  - ${name}`);
    }
  }
  if (result.conflicts.length > 0) {
    console.log(`
Warning: ${result.conflicts.length} file conflict(s) detected (later plugin overwrote earlier):`);
    for (const conflict of result.conflicts) {
      console.log(`  ${conflict}`);
    }
  }
  console.log(`
Done. ${result.totalFiles} files from ${result.pluginCount} plugin(s).`);
});
program.command("add").description("Add and install a plugin (called from plugin postinstall)").argument("[package]", "Package name (auto-detected if run from postinstall)").action((packageArg) => {
  const projectRoot = findProjectRoot();
  const packageName = packageArg || process.env.npm_package_name;
  if (!packageName) {
    console.error("Error: Could not determine package name.");
    console.error("Please provide the package name as an argument: claude-plugins add <package>");
    process.exit(1);
  }
  const result = addPluginToProject(projectRoot, packageName);
  if (!result.success) {
    console.error(`Error: ${result.error}`);
    process.exit(1);
  }
  if (result.files.length === 0) {
    console.log(`Package ${packageName} has no Claude assets to install.`);
    return;
  }
  console.log(`Installed ${packageName}@${result.version}:`);
  for (const file of result.files) {
    console.log(`  .claude/${file}`);
  }
});
program.command("list").description("List installed plugins and their assets").action(() => {
  const projectRoot = findProjectRoot();
  const result = listPlugins(projectRoot);
  const pluginNames = Object.keys(result.plugins);
  if (pluginNames.length === 0) {
    console.log("No plugins installed.");
    return;
  }
  console.log("Installed Claude plugins:\n");
  for (const [packageName, entry] of Object.entries(result.plugins)) {
    console.log(`${packageName}@${entry.version}`);
    for (const file of entry.files) {
      console.log(`  .claude/${file}`);
    }
    console.log();
  }
});
program.command("remove").description("Remove a plugin and its assets (called from plugin preuninstall)").argument("[package]", "Package name (auto-detected if run from preuninstall)").action((packageArg) => {
  const projectRoot = findProjectRoot();
  const packageName = packageArg || process.env.npm_package_name;
  if (!packageName) {
    console.error("Error: Could not determine package name.");
    console.error("Please provide the package name as an argument: claude-plugins remove <package>");
    process.exit(1);
  }
  const result = removePluginFromProject(projectRoot, packageName);
  if (!result.success) {
    console.error(result.error);
    process.exit(1);
  }
  for (const file of result.filesRemoved) {
    console.log(`Removed .claude/${file}`);
  }
  console.log(`Removed ${packageName}`);
});
program.parse();
//# sourceMappingURL=cli.js.map